// Code generated by vfsgen; DO NOT EDIT.

// +build !dev

package main

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	pathpkg "path"
	"time"
)

// assets statically implements the virtual filesystem provided to vfsgen.
var assets = func() http.FileSystem {
	fs := vfsgen۰FS{
		"/": &vfsgen۰CompressedFileInfo{
			name:             "/",
			modTime:          time.Date(2019, 8, 1, 17, 33, 46, 863706417, time.UTC),
			uncompressedSize: 2940,

			compressedContent: []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xb4\x56\x61\x6f\xe3\xb8\x11\xfd\x6c\xfd\x8a\xa9\xee\x3e\xb4\x85\x2b\xef\xee\xb7\xba\xbd\x06\x6e\x36\x69\x8d\x1e\xe2\x22\xce\xf6\x70\x68\xaf\xc0\x98\x1a\x49\xb3\x4b\x91\x5c\x92\xb2\x63\x74\xb7\xbf\xbd\x18\x52\xb2\x95\xb4\x1f\x7b\x06\x02\xc4\xd2\xf0\xf1\xf1\xbd\x37\x43\xaf\x56\x70\x6b\xdd\xd9\x73\xdb\x45\x78\xf7\xe6\xed\x6f\x61\x1b\x22\x5b\xd8\x0c\xb1\xb3\x3e\x14\xab\x55\xb1\x5a\xc1\xf7\xac\xc8\x04\xaa\x61\x30\x35\x79\x88\x1d\xc1\xc6\xa1\xea\x68\x7a\xb3\x84\xbf\x91\x0f\x6c\x0d\xbc\xab\xde\xc0\x2f\xa5\xa0\x1c\x5f\x95\xbf\xfa\x9d\x40\x9c\xed\x00\x3d\x9e\xc1\xd8\x08\x43\x20\x88\x1d\x07\x68\x58\x13\xd0\xb3\x22\x17\x81\x0d\x28\xdb\x3b\xcd\x68\x14\xc1\x89\x63\x97\xf6\x19\x51\x2a\xc1\xf8\x71\xc4\xb0\x87\x88\x6c\x00\x41\x59\x77\x06\xdb\xcc\x0b\x01\xe3\x48\x5a\x3e\x5d\x8c\x6e\xbd\x5a\x9d\x4e\xa7\x0a\x13\xe1\xca\xfa\x76\xa5\x73\x69\x58\x7d\xbf\xbd\xbd\x7b\xd8\xdf\xfd\xe6\x5d\xf5\x66\x5c\xf4\xc1\x68\x0a\x01\x3c\x7d\x1e\xd8\x53\x0d\x87\x33\xa0\x73\x9a\x15\x1e\x34\x81\xc6\x13\x58\x0f\xd8\x7a\xa2\x1a\xa2\x15\xd2\x27\xcf\x91\x4d\xbb\x84\x60\x9b\x78\x42\x4f\x02\x53\x73\x88\x9e\x0f\x43\x7c\xa1\xd9\x44\x91\xc3\x8b\x02\x6b\x00\x0d\x94\x9b\x3d\x6c\xf7\x25\xfc\x71\xb3\xdf\xee\x97\x02\xf2\xc3\xf6\xe9\xcf\xbb\x0f\x4f\xf0\xc3\xe6\xf1\x71\xf3\xf0\xb4\xbd\xdb\xc3\xee\x11\x6e\x77\x0f\xef\xb7\x4f\xdb\xdd\xc3\x1e\x76\xf7\xb0\x79\xf8\x11\xfe\xb2\x7d\x78\xbf\x04\xe2\xd8\x91\x07\x7a\x76\x5e\x4e\x60\x3d\xb0\xa8\x49\x75\x92\x6e\x4f\xf4\x82\x42\x63\x33\xa5\xe0\x48\x71\xc3\x0a\x34\x9a\x76\xc0\x96\xa0\xb5\x47\xf2\x86\x4d\x0b\x8e\x7c\xcf\x41\x5c\x0d\x80\xa6\x16\x18\xcd\x3d\x47\x8c\xe9\xd1\x7f\x9d\xab\x2a\xa4\xe4\xe9\x62\x6c\x4d\x41\x79\x3e\x50\x48\x45\x78\x44\xd6\x49\xc5\x86\x49\xd7\xe1\x42\xa1\x25\x63\x1d\x32\x28\x6b\x1a\x6e\x07\x9f\xe0\x13\x42\x62\xbe\x73\xf2\x1d\xf5\xb4\x0c\x3d\x01\x9b\x9a\x15\x8a\x76\x29\x27\x08\x9f\x07\x0a\x69\x59\x8f\xfe\x53\xe6\xd1\xdb\x7a\xd0\x04\xca\x7a\x4f\xc1\x59\x53\x07\x31\x4c\x36\xfc\x93\x15\x75\x6e\x3f\xdc\x4d\x35\xb6\x01\x04\x4f\xce\x06\x8e\xd6\x9f\x97\x70\xea\x58\x75\x62\x53\xec\x46\x3b\x3d\x29\x79\x05\xce\x53\xc3\xcf\x92\xe0\x94\x0d\x87\xea\x13\xb6\x14\x12\x0f\x36\x09\x7e\x04\x95\x74\xf4\xce\xfa\x08\x84\xaa\x03\x2b\xee\xa4\x03\xdd\x5b\x71\x09\x7b\xa7\x69\x99\x44\x68\x39\x76\xc3\xa1\x52\xb6\x5f\xb1\x9c\x62\x85\x8e\x97\x73\x28\x0e\x50\xa6\x37\x55\x7e\x59\x56\x45\x7e\xb3\x06\x49\x91\x69\x8b\xc2\x3a\x32\xe8\xf8\x66\x0d\xff\x2a\x16\xab\x15\x04\xd2\xcd\xad\x35\xd2\x27\x54\x4f\x2e\x0b\xcf\x8e\x52\x4c\x50\x6b\xf0\xd4\x90\x27\xa3\x28\x40\xe8\xec\xa0\x6b\x38\x88\xb4\x4a\x0f\xf5\xa8\x2c\x9b\x04\x26\x54\x76\x8e\xcc\xe6\xaf\x5b\xb0\x43\x74\x43\x5c\x82\x27\x35\xf8\xc0\x47\xd2\xe7\xaa\x58\xbc\xd8\x6e\x0d\x07\x6b\x35\x7c\x81\x5f\x37\xa8\x03\x15\x09\x23\xb9\x77\xcf\x3a\x92\x87\x9a\x1a\x36\x14\x92\xe8\xed\xa0\xf1\x92\x5a\x71\x50\xcc\xd0\x17\xb7\xa3\x05\xdb\x73\x84\xc6\xdb\x3e\xb9\x21\x58\x99\x43\x05\xdb\x28\xd2\x58\xa3\xcf\xb2\xc4\x9e\x72\x4f\x36\x79\x93\x09\xa0\xc3\x08\x58\xd7\xf2\xc7\x39\x49\x09\x43\x59\x13\xa2\x47\x36\x31\x54\x70\x3f\xab\x9d\xb2\x05\x07\x0c\xac\x20\x9e\x1d\x05\x50\x68\x64\x70\x1d\x08\x3c\xf5\xf6\x48\xf5\xb8\x79\x82\x42\x03\xe4\xbd\xf5\xc9\xcc\x30\xa8\x6e\x46\xfe\x90\xe6\x5b\x56\xf4\x70\xbe\x4c\xbd\x28\x59\x90\xb5\xf7\xd7\x50\x7f\x1e\x50\x8b\x49\x63\x21\xb1\x87\xdd\xe1\x23\xa9\x98\x38\x54\x29\x37\x6c\x42\x94\xf9\xb8\xbc\x68\xd1\xb3\xe1\x7e\xe8\xf3\x96\xd3\x2c\x0c\xaa\xa3\x1e\xc1\xe6\xe5\x1c\x66\xd8\x18\x60\x9f\xde\xae\xc6\x95\x55\xb1\x98\x79\x73\x73\x8d\x94\xa0\xd3\xb3\x43\x53\x3f\x5e\x83\xe2\xc9\x69\xcc\xff\x5c\x9e\xe5\x1e\x54\x71\x40\x3d\x6e\x99\x72\x66\xa4\xb3\x49\xda\xd9\xb4\x09\x6c\x8a\x50\xde\x7f\xb2\xef\x85\x7a\x68\x52\x5f\x1e\x51\x0f\xa9\x83\xd2\x2e\xa9\x95\xa2\x44\x0c\xb8\x19\x03\x29\xbe\xa7\xc1\x20\x10\xd2\x8d\x55\xb1\x78\x4d\xf6\x75\x0e\xbf\x8e\xf3\x89\x52\xc0\x02\xa9\xb4\xfe\xda\x1b\x81\xa2\x70\xcd\x93\xe9\xca\x5d\x48\x61\xdb\x7a\x6a\x25\x15\xd3\x21\x64\x3e\x15\x89\x0a\x46\x09\x93\x44\x3f\x64\xe0\x2c\x7e\x0e\x79\x9d\x1e\x8d\xb6\x5c\xc7\x08\x99\xe8\x99\x42\x55\xa0\xd6\x97\x9e\xb5\xe8\xf8\x9e\x35\x19\xec\x69\x1c\x3e\x69\x9b\xf4\x7d\x36\x2d\x85\x17\xd5\xaf\x3a\xb2\x2a\x16\xf3\xf5\x6b\xf8\xee\xdf\x65\xf5\x31\x58\xf3\x6d\x99\xad\x8c\x1c\x65\xd4\x1d\xc9\x7b\xae\xc7\x99\xfc\x6d\x1e\xd1\x59\x48\x0c\xc1\x2a\x9e\x4f\xd5\x0b\xdf\xaa\x58\xa4\xe5\xb3\x70\x1c\xf3\x7d\x2f\xfb\x7c\x53\xfe\xf3\xf8\x8f\xba\x2a\xbf\x11\xa9\xcb\xe3\x5b\x74\xba\xc3\xb7\xe5\xa8\xf7\x04\x22\x0a\x8b\xdd\xd0\xa3\x13\x41\x66\xcf\x65\x9a\x68\x8c\x7c\xa4\x69\x44\x7b\x6b\x63\x1e\x8e\x79\x14\x47\x2b\x50\xce\x5b\x25\x77\x9b\xf3\x36\xf7\xb9\x28\x38\xc7\xff\xfd\x7b\xf6\x7f\x58\xc3\xdf\xab\xaa\xca\x92\xf6\xb6\xbe\xde\x16\x61\x04\x9b\x2d\xcf\x77\x78\xea\x4f\xb9\xcb\xaf\xe2\x5e\x44\x4d\x3f\x24\xc4\xc3\xf4\x99\x6a\xe5\xc1\x0c\x66\x2c\x73\xe4\x45\x7f\xb8\xe0\x00\x42\x20\x87\xfe\x75\x70\xd2\xc9\xd2\xb5\x70\x05\x29\x16\x42\xf6\x66\x0d\x25\x6a\x5d\xc2\x17\x28\x47\xb8\xd1\xbf\x54\x79\x9f\x48\xf7\x68\x06\xd4\xfa\x7c\xc9\x6e\x9d\x44\xd3\x1c\xa2\x28\xfb\xbf\xcf\x57\x15\x8b\x2b\xc4\x4d\x16\x29\xbb\xf9\x53\xf1\x7f\x88\x5f\xba\xc6\xd1\x71\x82\x3a\xb1\xe8\xc3\xea\x13\xa4\x3e\xc0\x41\x47\xc8\xb0\x0d\x0c\xe6\xc2\xfa\x55\x66\x6f\x7e\x9e\xd0\xde\xac\xe1\x17\xdf\x95\x23\xe0\x18\xdb\x59\xd7\x0b\xe4\xf4\x54\xee\x1e\xf3\xc2\xa9\x2a\xcd\x8b\xe9\x0c\xb3\xda\x3c\xf9\xc3\xcc\x82\xf1\xfa\x9f\xfd\x56\xc0\xd8\x55\x97\x4e\xb9\x79\xd1\x2a\xc5\xd7\x9f\x8a\xff\x04\x00\x00\xff\xff\x8a\x79\x11\xee\x7c\x0b\x00\x00"),
		},
	}

	return fs
}()

type vfsgen۰FS map[string]interface{}

func (fs vfsgen۰FS) Open(path string) (http.File, error) {
	path = pathpkg.Clean("/" + path)
	f, ok := fs[path]
	if !ok {
		return nil, &os.PathError{Op: "open", Path: path, Err: os.ErrNotExist}
	}

	switch f := f.(type) {
	case *vfsgen۰CompressedFileInfo:
		gr, err := gzip.NewReader(bytes.NewReader(f.compressedContent))
		if err != nil {
			// This should never happen because we generate the gzip bytes such that they are always valid.
			panic("unexpected error reading own gzip compressed bytes: " + err.Error())
		}
		return &vfsgen۰CompressedFile{
			vfsgen۰CompressedFileInfo: f,
			gr:                        gr,
		}, nil
	case *vfsgen۰DirInfo:
		return &vfsgen۰Dir{
			vfsgen۰DirInfo: f,
		}, nil
	default:
		// This should never happen because we generate only the above types.
		panic(fmt.Sprintf("unexpected type %T", f))
	}
}

// vfsgen۰CompressedFileInfo is a static definition of a gzip compressed file.
type vfsgen۰CompressedFileInfo struct {
	name              string
	modTime           time.Time
	compressedContent []byte
	uncompressedSize  int64
}

func (f *vfsgen۰CompressedFileInfo) Readdir(count int) ([]os.FileInfo, error) {
	return nil, fmt.Errorf("cannot Readdir from file %s", f.name)
}
func (f *vfsgen۰CompressedFileInfo) Stat() (os.FileInfo, error) { return f, nil }

func (f *vfsgen۰CompressedFileInfo) GzipBytes() []byte {
	return f.compressedContent
}

func (f *vfsgen۰CompressedFileInfo) Name() string       { return f.name }
func (f *vfsgen۰CompressedFileInfo) Size() int64        { return f.uncompressedSize }
func (f *vfsgen۰CompressedFileInfo) Mode() os.FileMode  { return 0444 }
func (f *vfsgen۰CompressedFileInfo) ModTime() time.Time { return f.modTime }
func (f *vfsgen۰CompressedFileInfo) IsDir() bool        { return false }
func (f *vfsgen۰CompressedFileInfo) Sys() interface{}   { return nil }

// vfsgen۰CompressedFile is an opened compressedFile instance.
type vfsgen۰CompressedFile struct {
	*vfsgen۰CompressedFileInfo
	gr      *gzip.Reader
	grPos   int64 // Actual gr uncompressed position.
	seekPos int64 // Seek uncompressed position.
}

func (f *vfsgen۰CompressedFile) Read(p []byte) (n int, err error) {
	if f.grPos > f.seekPos {
		// Rewind to beginning.
		err = f.gr.Reset(bytes.NewReader(f.compressedContent))
		if err != nil {
			return 0, err
		}
		f.grPos = 0
	}
	if f.grPos < f.seekPos {
		// Fast-forward.
		_, err = io.CopyN(ioutil.Discard, f.gr, f.seekPos-f.grPos)
		if err != nil {
			return 0, err
		}
		f.grPos = f.seekPos
	}
	n, err = f.gr.Read(p)
	f.grPos += int64(n)
	f.seekPos = f.grPos
	return n, err
}
func (f *vfsgen۰CompressedFile) Seek(offset int64, whence int) (int64, error) {
	switch whence {
	case io.SeekStart:
		f.seekPos = 0 + offset
	case io.SeekCurrent:
		f.seekPos += offset
	case io.SeekEnd:
		f.seekPos = f.uncompressedSize + offset
	default:
		panic(fmt.Errorf("invalid whence value: %v", whence))
	}
	return f.seekPos, nil
}
func (f *vfsgen۰CompressedFile) Close() error {
	return f.gr.Close()
}

// vfsgen۰DirInfo is a static definition of a directory.
type vfsgen۰DirInfo struct {
	name    string
	modTime time.Time
	entries []os.FileInfo
}

func (d *vfsgen۰DirInfo) Read([]byte) (int, error) {
	return 0, fmt.Errorf("cannot Read from directory %s", d.name)
}
func (d *vfsgen۰DirInfo) Close() error               { return nil }
func (d *vfsgen۰DirInfo) Stat() (os.FileInfo, error) { return d, nil }

func (d *vfsgen۰DirInfo) Name() string       { return d.name }
func (d *vfsgen۰DirInfo) Size() int64        { return 0 }
func (d *vfsgen۰DirInfo) Mode() os.FileMode  { return 0755 | os.ModeDir }
func (d *vfsgen۰DirInfo) ModTime() time.Time { return d.modTime }
func (d *vfsgen۰DirInfo) IsDir() bool        { return true }
func (d *vfsgen۰DirInfo) Sys() interface{}   { return nil }

// vfsgen۰Dir is an opened dir instance.
type vfsgen۰Dir struct {
	*vfsgen۰DirInfo
	pos int // Position within entries for Seek and Readdir.
}

func (d *vfsgen۰Dir) Seek(offset int64, whence int) (int64, error) {
	if offset == 0 && whence == io.SeekStart {
		d.pos = 0
		return 0, nil
	}
	return 0, fmt.Errorf("unsupported Seek in directory %s", d.name)
}

func (d *vfsgen۰Dir) Readdir(count int) ([]os.FileInfo, error) {
	if d.pos >= len(d.entries) && count > 0 {
		return nil, io.EOF
	}
	if count <= 0 || count > len(d.entries)-d.pos {
		count = len(d.entries) - d.pos
	}
	e := d.entries[d.pos : d.pos+count]
	d.pos += count
	return e, nil
}
